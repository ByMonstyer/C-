问MainFrm,CDocument和CView类之间的关系,

MainFrm为框架类，包含应用程序外框所包含部分。CView为视图类，用于显示数据的空白区域窗口。

CDocument为文档类。

MFC提供了文档/视类结构，采用数据本身和显示分离的机制。其中文档类CDocument用于数据的存储和加载，视类CView用于数据的显示与修改。

 

Dialog和 ModuelDialog不同用法

1）类型不同

MoudleDialog 模态对话框，属于垄断对话框，例如打开对话框，点击打开后不能再执行其他操作，会发出“嘟嘟嘟”的声音；

      非模态对话框，属于非垄断对话框，利用查找对话框，点击查找同时可以执行其他操作；

      即：非模态不垄断；模态垄断。

2）用法不同

      CDialog::Create ：to create amodelessdialog box

      CDialog::DoModal ：Call thismember function to invoke the modal dialog box andreturn the dialog-box resultwhen done

 

windows消息系统由哪几部分构成?

答：由一下3部分组成：

1.   消息队列：操作系统负责为进程维护一个消息队列，程序运行时不断从该消息队列中获取消息、处理消息；

2.   消息循环：应用程序通过消息循环不断获取消息、处理消息。

3.   消息处理：消息循环负责将消息派发到相关的窗口上使用关联的窗口过程函数进行处理。

 

什么时候必须重写拷贝构造函数?

答：当构造函数涉及到动态存储分配空间时，要自己写拷贝构造函数，并且要深拷贝。

 

 什么是消息映射?

答：消息映射就是让程序员指定MFC类（有消息处理能力的类）处理某个消息。然后由程序员完成对该处理函数的编写，以实现消息处理功能。

 

如何定义和实现一个类的成员函数为回调函数?

答：

所谓的回调函数，就是预先在系统的对函数进行注册，让系统知道这个函数的存在，以后，当某个事件发生时，再调用这个函数对事件进行响应。

定义一个类的成员函数时在该函数前加CALLBACK即将其定义为回调函数，函数的实现和普通成员函数没有区别

 

MFC为何使用消息映射表而不用虚函数？

这个问题是windows开发面试中最经常问到得问题，也是很有深度的一个问题。
有两个帖子对该问题讨论的比较深刻：
http://topic.csdn.net/u/20090822/16/4cf5d189-0e5e-41ff-9ba3-c7eaf2f6da74.html
http://topic.csdn.net/u/20090316/22/8b067591-6a17-4970-b224-41ab589294b3.html
说法一：
虚函数实现占用内存较大
      侯捷在《深入浅出MFC》中说微软使用消息映射机制而不用虚函数，是因为虚函数空间代价的原因。在当前MFC2.0版本发布的时候是92年，pc的内存才几M。一个类的虚表的大小就是虚函数的个数*一个指针的大小。
         假设windows的通用消息有200个，那么CWnd类的虚表就有 200*4个byte = 800byte，CWnd类的所有派生类均copy了一份CWnd的虚表vtable，然后自己的虚函数往后加CWnd类的虚表的后头。
         （至于有人说CWnd类的派生类能共享CWnd的虚表，这个说法不靠谱。因为派生类自己的虚函数值加在基类的虚函数表项的最后的。如果CWnd派生了CWndChildA 和 CWndChildB，且两个孩子均有自己的虚函数，那么都往CWnd类的后面加，岂不是冲突了？）。

         也就是系统内所有的CWnd类的派生类都要承受 800byte的代价。假设有100个类派生自CWnd 那么代价就是800*100byte 也就是 80K。这在当时内存很紧张的情况下，已经是一种巨大的内存消耗了！这里需要注意一点：vtable是和类绑定在一起的，而不是和类对象（也叫类的实例）绑定在一起的，类的实例仅增加一个指向该向类的vtable的指针而已。也就是说，如果你有100个CWnd派生类，哪怕你生成了100000个派生类的实例，vtable占用的内存也是80K。
     看来在当时的环境看来，MFC没有采用虚函数，内存的确是一个考虑。
但是放在现在看，这点内存消耗确实微不足道的！也就是说，如果现在重新设计MFC的消息机制，如果不采用虚函数，并非因为虚函数的空间浪费问题。

结论：这个说法靠谱。

说法二：
         消息映射机制效率比虚函数效率高。
       因为那么多消息ID，如果找到其对应的消息处理函数，switch是不可少的！（可以hash？哦哦，的确可能，不过mfc里面可没这么做？mfc里面怎么做的我也不清楚）
MFC中采用的是消息映射的机制，而没有用虚函数的机制，因为消息有很多，如果用虚函数机制，需要给每个消息定义一个虚函数，在分派消息时，程序需要逐一判断是哪一个消息，找到合适的分支后再调用相应的虚函数；而通常情况下，应用程序不需要响应太多的消息，消息映射方式只需要判断程序想要响应的这些消息即可，所以开销小。 

         也就是说，MFC采用了消息映射而没有采用虚函数，是从对消息的响应机制来考虑的。 消息映射，就可以仅实现自己感兴趣的消息，这样switch时就可以快一点。
      不过话又说回来，对一个非自己感兴趣的系统消息来了以后，就需要遍历消息网，层层的向基类查找直到找到对应的消息处理函数！这本身也很浪费时间！也许这种情况比较少见吧，否则的话，消息映射的消息响应时间并不比虚函数来的快！因为虚函数最多只需一次遍历，而且，如果可以采用hash技术，更快！
如果说，大多数消息都是系统的消息，那么消息映射的迭代查找消息函数的方式并不比虚函数的switch来的快！
         PS：这里有一篇对比消息映射机制和虚函数机制效率的简单模拟实验
         http://blog.csdn.net/hjsunj/archive/2008/01/10/2034314.aspx 

结论，该说法不靠谱！

说法三：
         为了未来的可扩展性。兼容新的系统级的消息。
      我不是很清楚MS设计消息映射的初衷，但是感觉它着眼点更侧重于增加新消息很容易，而不是节省内存。 
如果我们使用虚函数机制实现，恐怕对于每个可能的消息我们都必须在基类中定义一个虚函数，而其首要的困难就是你无法猜测未来会出现什么消息，也无法确定需要定义什么样函数原型的虚函数。而使用消息映射，解决这个问题则相对容易，因为这将由未来的程序设计者决定他们的消息该如何处理。
     对于系统的新增消息，消息映射支持起来较方便。虚函数想要支持就需要改动基类添加虚函数。
对于自定义的消息，无论消息映射和虚函数都可以很好的支持。
那么虚函数方式如何支持自定义消息?
    自定义消息是不需要加到基类的。基类可以加个虚函数，OnMessage(xxx), 然后有自定义消息的类实现之，用switch转换成相应虚函数调用，不是自己的消息再传给基类。
结论：这个说法靠谱。

 

sendMessage与postMessage区别？

不同点：sendMessage发送完毕以后需要等待处理完才返回；而postMessage发送消息后立即返回。

Do not post the WM_QUIT message usingPostMessage; use thePostQuitMessage function.

postMessage将消息放置到消息队列中，不等待线程处理消息就立即返回。

sendMessage发送指定的消息到窗口，并会调用窗口过程，直到窗口过程处理完毕后才返回。

 

TCP的重发机制是怎么实现的？

       1.滑动窗口机制，确立收发的边界，能让发送方知道已经发送了多少（已确认）、尚未确认的字节数、尚待发送的字节数；让接收方知道（已经确认收到的字节数）。

       2.选择重传，用于对传输出错的序列进行重传。

TCP和UDP的区别？

       1）TCP面向连接（三次握手机制），通信前需要先建立连接；UDP面向无连接，通信前不需要建立连接；

       2）TCP保障可靠传输（按序、无差错、不丢失、不重复）；UDP不保障可靠传输，使用最大努力交付；

       3）TCP面向字节流的传输，UDP面向数据报的传输。

 

TCP为什么不是两次连接？而是三次握手？

如果A与B两个进程通信，如果仅是两次连接。可能出现的一种情况就是：A发送完请报文以后，由于网络情况不好，出现了网络拥塞，即B延时很长时间后收到报文，即此时A将此报文认定为失效的报文。B收到报文后，会向A发起连接。此时两次握手完毕，B会认为已经建立了连接可以通信，B会一直等到A发送的连接请求，而A对失效的报文回复自然不会处理。依次会陷入B忙等的僵局，造成资源的浪费。

connect方法会阻塞，请问有什么方法可以避免其长时间阻塞？

可以考虑采用异步传输机制，同步传输与异步传输的主要区别在于同步传输中，如果调用recvfrom后会一致阻塞运行，从而导致调用线程暂停运行；异步传输机制则不然，会立即返回。

网络编程中设计并发服务器，使用多进程与多线程，请问有什么区别？

答案一:

1，进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。

2，线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。两者都可以提高程序的并发度，提高程序运行效率和响应时间。

线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。

答案二:

根本区别就一点：用多进程每个进程有自己的地址空间(address space)，线程则共享地址空间。所有其它区别都是由此而来的：

1。速度：线程产生的速度快，线程间的通讯快、切换快等，因为他们在同一个地址空间内。

2。资源利用率：线程的资源利用率比较好也是因为他们在同一个地址空间内。

3。同步问题：线程使用公共变量/内存时需要使用同步机制还是因为他们在同一个地址空间内。等等

 

Windows编程的知识点，如消息机制，一个自定义消息如何实现。

       自定义消息共分为3步骤：

1）  自定义消息：#defineWM_MYMSGWM_USER+1

2）  在头文件中声明函数：      afx_msg voidonMyMsg();

3) 在消息映射中添加对应关系：

//BEGIN_MESSAGE_MAP(CDefMsgDemoDlg,CDialog)//END_MESSAGE_MAP()

ON_MESSAGE(WM_MYMSG,onMyMsg)

4）定义函数void onMyMsg();

核心即：函数原型、关联消息与消息响应函数的宏、函数实现。

 

SNMP协议

       简单网络管理协议——应用层协议.

       包括5种数据包：Get-Request;Get-Next-Request;Set-Request, Get-Response; Trap;

RAW套接字

       广泛应用于高级网络编程，如SNIFFER、拒绝服务、IP欺骗都是通过原始套接字实现的。

 

窗口创建的步骤：

1）设计窗口类(填充结构体)à2）注册窗口类RegisterClassà3）创建窗口；4）显示ShowWindow&更新窗口UpdateWindowà4）循环获取消息GetMessage（）{翻译（转换）TranslateMessage消息、处理消息DispathMessage（将消息交付给窗口过程进行处理）}。

 

当触发按钮以后发生了什么？

       1）比如点击鼠标左键后，操作系统首先会感知到该事件；2）操作系统将事件其转化为消息；3）操作系统将消息投递到对应程序（线程）的消息队列中；4）应用程序（线程）从消息队列中通过GetMessage获取消息，并通过DispathMessge将消息交付给操作系统；5）操作系统通过设计窗口类时指定的窗口过程对对消息进行处理。

 

你平时是如何调试程序的？（引申）当一个程序在自己机器上运行正常，但是在其他机器上程序运行崩溃，如何查找原因？

断点调试：

值：查看变量（Variables）、表达式、内存（Memory）、寄存器（Register）的值。

进程控制：VC允许被中断的程序继续运行、单步运行和运行到指定光标处，分别对应快捷键F5、F10/F11和CTRL+F10。

其他调试手段：系统提供一系列特殊的函数或者宏来处理Debug版本相关的信息TRACE、ASSERT、VERIFy。Ctrl+B打开断点设置。

运行崩溃，如何查找原因? [提示后]，可以通过打印语句来发现错误！

 

线程、窗口、消息队列三者之间的关系？

MSDN上如是说：

Thethread to which the message is posted musthave created a message queue,or elsethe call to PostThreadMessagefails.  

并提供了如下两种解决方法：

CallPostThreadMessage.If it fails, call theSleep function and call PostThreadMessageagain. Repeat  until PostThreadMessage  succeeds. 

【面试官】说：一个线程对应一个或多个窗口（创建的关系），同时一个线程对应了一个消息队列。

【总结如下】：
1.在MFC程序框架里面，CWinThread专门负责线程创建的，它可以创建用户界面线程，及工作者线程。其中用户界面线程是包含消息队列的，而工作者线程是不包含消息队列的。即【一句话】：用户界面线程对应一个消息队列。
2.CWinThread类和CWnd类都派生自CCmdTarget，而CDialog对话框类、视图类CView都派生自CWnd。
【深入浅出MFC里一句话】：不是每一个窗口都产生一个线程（因为要付出昂贵的线程切换代价）。即，深入理解之：一个线程可以对应多个窗口。主线程可以创建出其所要的全部窗口。
【结论】一个UI线程就1组消息队列集合，一个线程可以创建多个窗口。

 

OSI 7层模型是什么? 每层有哪些协议？  

应用层 FTP、Telnet、SMTP、HTTP、RIP、NFS、DNS 表示层 示例：加密，ASCII等 会话层 示例：RPC，SQL等 传输层 示例：TCP，UDP，SPX 

网络层 示例：IP协议、ICMP协议、ARP协议、RARP协议  数据链路层 示例：ATM，FDDI等 物理层 示例：Rj45，802.3等 

 

请写出下列服务使用的默认端口POP3、SMTP、FTP、MSN、DNS、SQL  

端口：21   服务：FTP  

端口：22   服务：SSH  端口：23   服务：Telnet  端口：25   服务：SMTP  端口：80   服务：HTTP  

端口：110   服务：Post Office Protocol -Version3 (pop3) 端口:569     服务:Membership MSN  端口1433和1434  服务:SQL 

DNS协议运行在UDP之上,使用端口号53
————————————————
版权声明：本文为CSDN博主「在南京看海」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_33336155/article/details/53859214